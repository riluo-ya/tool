<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>QRepository - äºŒç»´ç å‹ç¼©åŒ…</title>

    <!-- å¤–éƒ¨ä¾èµ– -->
    <script src="https://cdn.jsdelivr.net/npm/fflate"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>

<!-- æœ¬åœ°ä¾èµ– -->
<script src="./fflate.js"></script>
<script src="./min.js"></script>

    <!-- å¼•å…¥ç°ä»£å­—ä½“ -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">

    <style>
        :root {
            --primary-color: #6366f1;
            --primary-hover: #4f46e5;
            --secondary-color: #a855f7;
            --accent-color: #06b6d4;
            --success-color: #10b981;
            --warning-color: #f59e0b;
            --error-color: #ef4444;
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-tertiary: #334155;
            --text-primary: #f8fafc;
            --text-secondary: #cbd5e1;
            --text-muted: #94a3b8;
            --border-color: #475569;
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
            --radius-sm: 0.375rem;
            --radius-md: 0.5rem;
            --radius-lg: 0.75rem;
            --radius-xl: 1rem;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
            margin: 0;
            color: var(--text-primary);
            min-height: 100vh;
            line-height: 1.6;
        }

        header {
            background: rgba(15, 23, 42, 0.8);
            backdrop-filter: blur(20px);
            color: var(--text-primary);
            text-align: center;
            padding: 3rem 1.5rem 2rem;
            border-bottom: 1px solid var(--border-color);
            box-shadow: var(--shadow-lg);
        }

        header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin: 0;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        header h3 {
            font-size: 1.125rem;
            font-weight: 400;
            margin: 0.5rem 0 1.5rem;
            color: var(--text-secondary);
            opacity: 0.8;
        }

        #status {
            margin-top: 1rem;
            font-size: 0.875rem;
            color: var(--text-muted);
            padding: 0.5rem 1rem;
            background: rgba(99, 102, 241, 0.1);
            border-radius: var(--radius-lg);
            display: inline-block;
            border: 1px solid rgba(99, 102, 241, 0.2);
        }

        nav {
            background: rgba(30, 41, 59, 0.5);
            backdrop-filter: blur(10px);
            display: flex;
            justify-content: center;
            padding: 1rem;
            gap: 0.5rem;
            border-bottom: 1px solid var(--border-color);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        button, .file-label, .btn {
            font-family: inherit;
            font-size: 0.875rem;
            font-weight: 500;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: var(--radius-lg);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            min-height: 44px;
        }

        nav button {
            background: rgba(99, 102, 241, 0.1);
            color: var(--text-primary);
            border: 1px solid rgba(99, 102, 241, 0.2);
            font-weight: 500;
            font-size: 0.875rem;
        }

        nav button:hover {
            background: rgba(99, 102, 241, 0.2);
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        nav button.active {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            border-color: transparent;
            box-shadow: var(--shadow-lg);
        }

        .tab {
            display: none;
            padding: 3rem 1.5rem;
            max-width: 800px;
            margin: 0 auto;
            min-height: 60vh;
        }

        .tab.active {
            display: block;
            animation: fadeIn 0.5s ease-in-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        section h2 {
            text-align: center;
            color: var(--text-primary);
            font-size: 2rem;
            font-weight: 600;
            margin-bottom: 2rem;
            background: linear-gradient(135deg, var(--primary-color), var(--accent-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .form-group {
            margin: 1.5rem 0;
            text-align: center;
        }

        .form-group input,
        .form-group textarea,
        .form-group select {
            font-size: 0.875rem;
            padding: 0.75rem 1rem;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            transition: all 0.3s ease;
            width: 100%;
            max-width: 400px;
            margin: 0.5rem auto;
        }

        .form-group input:focus,
        .form-group textarea:focus,
        .form-group select:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }

        .file-label {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            font-weight: 500;
            box-shadow: var(--shadow-md);
            transition: all 0.3s ease;
        }

        .file-label:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-xl);
            background: linear-gradient(135deg, var(--primary-hover), var(--secondary-color));
        }

        .file-label:active {
            transform: translateY(0);
        }

        .form-group label {
            font-size: 0.875rem;
            color: var(--text-secondary);
            font-weight: 500;
            display: block;
            margin-bottom: 0.5rem;
        }

        .inline {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        canvas {
            max-width: 90%;
            width: 400px;
            height: auto;
            display: block;
            margin: 2rem auto;
            border-radius: var(--radius-xl);
            box-shadow: var(--shadow-xl);
            border: 1px solid var(--border-color);
            background: white;
        }

        footer {
            background: rgba(30, 41, 59, 0.5);
            backdrop-filter: blur(10px);
            text-align: center;
            padding: 2rem;
            font-size: 0.875rem;
            color: var(--text-muted);
            border-top: 1px solid var(--border-color);
            margin-top: auto;
        }

        /* è¿›åº¦æ¡æ ·å¼ */
        #decodeProgressWrap, #encodeProgressWrap {
            max-width: 500px;
            margin: 2rem auto;
            padding: 1rem;
            background: var(--bg-secondary);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-md);
        }

        #decodeProgressText, #encodeProgressText {
            text-align: center;
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-bottom: 0.75rem;
            font-weight: 500;
        }

        #decodeProgressBar, #encodeProgressBar {
            height: 8px;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            border-radius: var(--radius-sm);
            transition: width 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        #decodeProgressBar::before,
        #encodeProgressBar::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        /* å¤é€‰æ¡†æ ·å¼ */
        input[type="checkbox"] {
            width: 1.125rem;
            height: 1.125rem;
            accent-color: var(--primary-color);
            margin-right: 0.5rem;
        }

        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 768px) {
            header {
                padding: 2rem 1rem;
            }
            
            header h1 {
                font-size: 2rem;
            }
            
            .tab {
                padding: 2rem 1rem;
            }
            
            nav {
                padding: 0.75rem;
                gap: 0.25rem;
            }
            
            nav button {
                padding: 0.5rem 1rem;
                font-size: 0.8rem;
            }
        }

        /* é¢å¤–ç¾åŒ–å…ƒç´  */
        .glass-effect {
            background: rgba(30, 41, 59, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(99, 102, 241, 0.2);
            border-radius: var(--radius-lg);
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            font-weight: 600;
            box-shadow: var(--shadow-md);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-xl);
        }

        .btn-primary:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: rgba(99, 102, 241, 0.1);
            color: var(--text-primary);
            border: 1px solid rgba(99, 102, 241, 0.2);
        }

        .btn-secondary:hover {
            background: rgba(99, 102, 241, 0.2);
            transform: translateY(-1px);
        }

        /* GitHub æŒ‰é’®ç‰¹æ®Šæ ·å¼ */
        [href*="github.com"] {
            background: linear-gradient(135deg, #333, #666);
            color: white;
            font-weight: 600;
            text-decoration: none;
            padding: 0.75rem 1.5rem;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-md);
            transition: all 0.3s ease;
        }

        [href*="github.com"]:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-xl);
            background: linear-gradient(135deg, #444, #777);
        }
    </style>
</head>

<body>
    <header>
        <h1>äºŒç»´ç å‹ç¼©åŒ…</h1>
        <h3>QRepository</h3>

        <!-- ç°ä»£åç¾æŒ‰é’® -->
        <a href="https://github.com/Stellate0511/QRepository"
            target="_blank"
            style="margin: 1.5rem 0;">
            <i class="fab fa-github"></i>
            åŸä½œè€…ä»“åº“
        </a>

        <div id="status">â³ æ­£åœ¨åŠ è½½ä¾èµ–åº“ï¼Œè¯·ç¨å€™â€¦</div>
    </header>

    <nav>
        <button id="extractTab" class="active" onclick="switchTab('decoder')">
            <i class="fas fa-download"></i>
            æ–‡ä»¶æå–
        </button>
        <button id="embedTab" onclick="switchTab('encoder')">
            <i class="fas fa-lock"></i>
            æ–‡ä»¶åµŒå…¥
        </button>
    </nav>

    <!-- è§£ç é¡µï¼ˆé»˜è®¤ï¼‰ -->
    <section id="decoder" class="tab active">
        <h2>ğŸ“¥ æ–‡ä»¶æå–</h2>

        <div class="form-group">
            <label for="imageInput" class="file-label">
                <i class="fas fa-image"></i>
                é€‰æ‹©äºŒç»´ç å›¾åƒ
            </label>
            <input type="file" id="imageInput" accept="image/*" style="display:none;" />
            <div id="imageInputName">æœªé€‰æ‹©ä»»ä½•å›¾ç‰‡</div>
        </div>

        <div class="form-group">
            <button id="decodeButton" class="btn-primary">
                <i class="fas fa-file-export"></i>
                æå–æ–‡ä»¶
            </button>
        </div>

        <!-- è§£ç é¡µè¿›åº¦æ¡ -->
        <div id="decodeProgressWrap" style="display:none;">
            <div id="decodeProgressText">å‡†å¤‡ä¸­â€¦</div>
            <div style="height:8px; background:var(--bg-tertiary); border-radius:4px; overflow:hidden;">
                <div id="decodeProgressBar" style="height:8px; width:0%; background:linear-gradient(90deg, var(--primary-color), var(--secondary-color));"></div>
            </div>
        </div>

        <div id="fileList" class="form-group"></div>
    </section>

    <!-- ç¼–ç é¡µ -->
    <section id="encoder" class="tab">
        <h2>ğŸ” æ–‡ä»¶åµŒå…¥</h2>

        <div class="form-group">
            <label for="filesInput" class="file-label">
                <i class="fas fa-folder-open"></i>
                é€‰æ‹©è¦åµŒå…¥çš„æ–‡ä»¶
            </label>
            <input type="file" id="filesInput" multiple style="display:none;" />
            <div id="filesInputName">æœªé€‰æ‹©ä»»ä½•æ–‡ä»¶</div>
        </div>

        <div class="form-group">
            <label for="qrLinkSelect">åµŒå…¥äºŒç»´ç é“¾æ¥ï¼š</label>
            <select id="qrLinkSelect" class="glass-effect">
                <option value="https://riluo-ya.github.io/tool/QRepository/">Github é¡µé¢</option>
                <option value="http://i9n.cn/n5yoL">çŸ­é“¾æ¥</option>
                <option value="custom">è‡ªå®šä¹‰</option>
            </select>
            <input type="text" id="customLinkInput" placeholder="è¯·è¾“å…¥è‡ªå®šä¹‰é“¾æ¥" class="glass-effect" style="display:none; margin-top:0.5rem;" />
        </div>

        <div class="form-group">
            <label for="embedMode">åµŒå…¥ç­–ç•¥ï¼š</label>
            <select id="embedMode" class="glass-effect">
                <option value="anticomp" selected>è¶…æŠ—å‹ç¼©ï¼ˆBç«™åŠ¨æ€æ¨èï¼ŒæŠ—ç”»è´¨å‹ç¼©ä½†ä¸æŠ—å¤§å°å‹ç¼©ï¼‰</option>
                <option value="pair41">æœ€å°ï¼ˆå¾®ä¿¡QQæ¨èï¼ŒäºŒç»´ç æœ‰ç•¥æ˜æ˜¾æ³¢åŠ¨ï¼‰</option>
                <option value="byte7">æœ€éšè”½ï¼ˆäºŒç»´ç ä¼šå¤§ä¸€åœˆï¼‰</option>
            </select>
        </div>

        <div class="form-group">
            <label class="inline">
                <input type="checkbox" id="convertToJpg" />
                <span>å°†æ‰€æœ‰å›¾ç‰‡è½¬ä¸º JPG æ ¼å¼ï¼ˆå‹ç¼©ç»“æœå›¾åƒå¤§å°ï¼‰</span>
            </label>

            <div id="jpgQualityContainer" style="display:none; margin-top:1rem;">
                <label for="jpgQuality">JPG å‹ç¼©è´¨é‡ï¼š</label>
                <select id="jpgQuality" class="glass-effect">
                    <option value="0.7">0.7ï¼ˆå°æ–‡ä»¶ï¼‰</option>
                    <option value="0.8" selected>0.8ï¼ˆæ¨èï¼‰</option>
                    <option value="0.9">0.9ï¼ˆé«˜è´¨é‡ï¼‰</option>
                    <option value="1.0">1.0ï¼ˆæœ€é«˜è´¨é‡ï¼‰</option>
                </select>
            </div>
        </div>

        <div class="form-group">
            <label class="inline">
                <input type="checkbox" id="extraInfoToggle" />
                <span>é™„åŠ æè¿°å›¾ç‰‡å’Œæ–‡æœ¬</span>
            </label>
        </div>

        <div id="extraInfoContainer" style="display: none;">
            <div class="form-group">
                <label for="previewImageInput" class="file-label">
                    <i class="fas fa-image"></i>
                    ä¸Šä¼ æè¿°å›¾ç‰‡ï¼ˆä¼šæ˜¾ç¤ºåœ¨äºŒç»´ç ä¸‹æ–¹ï¼‰
                </label>
                <input type="file" id="previewImageInput" accept="image/*" style="display:none;" />
                <div id="previewImageName">æœªé€‰æ‹©ä»»ä½•å›¾ç‰‡</div>
                <button type="button" id="clearPreviewImageButton" class="btn-secondary">
                    <i class="fas fa-times"></i>
                    æ¸…é™¤æè¿°å›¾ç‰‡
                </button>
            </div>
            <div class="form-group">
                <input type="text" id="descriptionInput" placeholder="è¾“å…¥æè¿°æ–‡å­—ï¼ˆä¼šæ˜¾ç¤ºåœ¨äºŒç»´ç ä¸‹æ–¹ï¼‰"
                    class="glass-effect">
            </div>
        </div>

        <div class="form-group">
            <button id="generateButton" class="btn-primary">
                <i class="fas fa-qrcode"></i>
                ç”ŸæˆäºŒç»´ç å›¾åƒ
            </button>
        </div>

        <!-- ç¼–ç é¡µè¿›åº¦æ¡ -->
        <div id="encodeProgressWrap" style="display:none;">
            <div id="encodeProgressText">å‡†å¤‡ä¸­â€¦</div>
            <div style="height:8px; background:var(--bg-tertiary); border-radius:4px; overflow:hidden;">
                <div id="encodeProgressBar" style="height:8px; width:0%; background:linear-gradient(90deg, var(--primary-color), var(--secondary-color));"></div>
            </div>
        </div>

        <canvas id="qrCanvas" width="512" height="512" style="max-width: 90%; height: auto; display: none;"></canvas>
        <div id="qrPreviewContainer" class="form-group"></div>
        <div class="form-group">
            <a id="downloadLink" class="btn-primary" style="display: none;">
                <i class="fas fa-download"></i>
                ä¸‹è½½äºŒç»´ç å›¾åƒ
            </a>
        </div>
    </section>

    <footer>
        <div style="display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
            <i class="fas fa-shield-alt"></i>
            <span>æœ¬å·¥å…·è¿è¡Œäºæµè§ˆå™¨æœ¬åœ° â€¢ æ— éœ€è”ç½‘ â€¢ æ‰€æœ‰æ•°æ®å¤„ç†å‡ä¸ä¸Šä¼ </span>
        </div>
    </footer>

    <script>
        document.getElementById("convertToJpg").addEventListener("change", function () {
            document.getElementById("jpgQualityContainer").style.display =
                this.checked ? "block" : "none";
        });

        // æ–°å¢ï¼šäºŒç»´ç é“¾æ¥é€‰æ‹©äº‹ä»¶ï¼Œå½“é€‰æ‹©â€œè‡ªå®šä¹‰â€æ—¶æ˜¾ç¤ºè‡ªå®šä¹‰è¾“å…¥æ¡†
        document.getElementById("qrLinkSelect").addEventListener("change", function() {
            const customInput = document.getElementById("customLinkInput");
            if (this.value === "custom") {
                customInput.style.display = "block";
            } else {
                customInput.style.display = "none";
            }
        });

        document.getElementById("generateButton").onclick = async function () {
            const files = document.getElementById("filesInput").files;
            if (files.length === 0) {
                alert("è¯·é€‰æ‹©æ–‡ä»¶");
                return;
            }

            const button = document.getElementById("generateButton");
            // ç¦ç”¨æŒ‰é’®å¹¶æ”¹æ–‡å­—
            button.disabled = true;
            const originalText = button.innerText;
            button.innerText = "å¤„ç†ä¸­â€¦";

            try {
                await generateDataQRCodeFromFiles(files);
            } catch (err) {
                console.error(err);
                alert("å¤„ç†å¤±è´¥ï¼š" + err.message);
            }

            // æ¢å¤æŒ‰é’®
            button.disabled = false;
            button.innerText = originalText;
        };

        function zipFilesAsync(fileList) {
            return new Promise((resolve, reject) => {
                const entries = {};          // { filename: Uint8Array }
                let readDone = 0;
                const total = fileList.length;
                if (total === 0) return resolve(new Uint8Array());

                const convertImages = document.getElementById('convertToJpg')?.checked === true;

                // â€”â€” å·¥å…·ï¼šç¡®ä¿ä¸é‡åï¼ˆè‡ªåŠ¨åŠ  " (1)", " (2)" â€¦ï¼‰â€”â€”
                const ensureUniqueName = (name) => {
                    const dot = name.lastIndexOf('.');
                    const base = dot >= 0 ? name.slice(0, dot) : name;
                    const ext = dot >= 0 ? name.slice(dot) : '';
                    let cand = name, k = 1;
                    while (Object.prototype.hasOwnProperty.call(entries, cand)) {
                        cand = `${base} (${k++})${ext}`;
                    }
                    return cand;
                };

                // â€”â€” å·¥å…·ï¼šæŠŠå›¾ç‰‡è½¬æˆ JPGï¼ˆç™½åº•ï¼‰ï¼Œè¿”å› { name, data: Uint8Array } â€”â€” 
                async function convertImageFileToJpeg(file, quality = 0.85) {
                    let canvas, ctx, width, height;

                    // å°è¯•æ›´ç¨³çš„è§£ç æ–¹å¼
                    let bitmap = null;
                    try {
                        bitmap = await createImageBitmap(file, {
                            imageOrientation: 'none',
                            premultiplyAlpha: 'none',
                            colorSpaceConversion: 'none'
                        });
                    } catch { /* å›é€€åˆ° <img> */ }

                    if (bitmap) {
                        width = bitmap.width; height = bitmap.height;
                        canvas = document.createElement('canvas');
                        canvas.width = width; canvas.height = height;
                        ctx = canvas.getContext('2d', { willReadFrequently: true });
                        ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, width, height);
                        ctx.drawImage(bitmap, 0, 0);
                    } else {
                        const url = URL.createObjectURL(file);
                        const img = await new Promise((res, rej) => {
                            const im = new Image();
                            im.onload = () => res(im);
                            im.onerror = () => rej(new Error('æ— æ³•è§£ç å›¾ç‰‡'));
                            im.src = url;
                        }).finally(() => URL.revokeObjectURL(url));
                        width = img.naturalWidth || img.width;
                        height = img.naturalHeight || img.height;
                        canvas = document.createElement('canvas');
                        canvas.width = width; canvas.height = height;
                        ctx = canvas.getContext('2d', { willReadFrequently: true });
                        ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, width, height);
                        ctx.drawImage(img, 0, 0);
                    }

                    const blob = await new Promise((res) => canvas.toBlob(res, 'image/jpeg', quality));
                    if (!blob) throw new Error('JPG ç¼–ç å¤±è´¥');
                    const data = new Uint8Array(await blob.arrayBuffer());

                    // ç»Ÿä¸€æ”¹æ‰©å±•åä¸º .jpg
                    const base = file.name.replace(/\.[^.]+$/, '');
                    return { name: `${base}.jpg`, data };
                }

                // â€”â€” å®Œæˆä¸€ä¸ªæ–‡ä»¶çš„å…¥åŒ… + è¿›åº¦ / è§¦å‘å‹ç¼© â€”â€” 
                const doneOne = async () => {
                    readDone++;
                    setProgress("encode", Math.floor((readDone / total) * 40), `è¯»å–æ–‡ä»¶â€¦(${readDone}/${total})`);
                    if (readDone === total) {
                        // å¼‚æ­¥ zipï¼Œä¸é˜»å¡ä¸»çº¿ç¨‹
                        setProgress("encode", 45, "å‹ç¼©ä¸­â€¦");
                        await uiTick();
                        fflate.zip(entries, { level: 9 }, (err, zipped) => {
                            if (err) return reject(err);
                            setProgress("encode", 60, "å‹ç¼©å®Œæˆ");
                            resolve(zipped);
                        });
                    }
                };

                // â€”â€” éå†æ–‡ä»¶ï¼šè¯»å– & å¯é€‰è½¬æ¢ â€”â€” 
                for (const file of fileList) {
                    const fr = new FileReader();
                    fr.onload = async () => {
                        try {
                            const isImage = file.type && file.type.startsWith('image/');
                            if (convertImages && isImage) {
                                // è‹¥å‹¾é€‰ï¼šæŠŠæ‰€æœ‰å›¾ç‰‡è½¬æˆ JPGï¼›è‹¥å·²æ˜¯ JPEG ç›´æ¥æ”¶å½•ï¼ˆé¿å…é‡å¤ç¼–ç ï¼‰
                                if (file.type === 'image/jpeg' || /\.jpe?g$/i.test(file.name)) {
                                    const unique = ensureUniqueName(file.name);
                                    entries[unique] = new Uint8Array(fr.result);
                                } else {
                                    try {
                                        const quality = parseFloat(document.getElementById("jpgQuality").value || "0.85");
                                        //console.log(quality);
                                        const { name, data } = await convertImageFileToJpeg(file, quality);
                                        const unique = ensureUniqueName(name);
                                        entries[unique] = data;
                                    } catch (e) {
                                        // è½¬æ¢å¤±è´¥ï¼Œå›é€€æˆåŸæ–‡ä»¶
                                        console.warn('å›¾ç‰‡è½¬æ¢å¤±è´¥ï¼Œå·²å›é€€åŸæ–‡ä»¶ï¼š', file.name, e);
                                        const unique = ensureUniqueName(file.name);
                                        entries[unique] = new Uint8Array(fr.result);
                                    }
                                }
                            } else {
                                // ä¸è½¬æ¢ï¼šåŸæ ·åŠ å…¥
                                const unique = ensureUniqueName(file.name);
                                entries[unique] = new Uint8Array(fr.result);
                            }
                        } catch (e) {
                            return reject(e);
                        }
                        await doneOne();
                    };
                    fr.onerror = () => reject(new Error(`æ— æ³•è¯»å–æ–‡ä»¶: ${file.name}`));
                    fr.readAsArrayBuffer(file);
                }
            });
        }

        async function composeFinalQRCodeCanvas(qrCanvas) {
            const useExtra = document.getElementById("extraInfoToggle").checked;
            if (!useExtra) return qrCanvas;

            const n = qrCanvas.width; // assume square
            const extraHeight = Math.floor(n * 0.25);
            const totalHeight = n + extraHeight;

            const finalCanvas = document.createElement("canvas");
            finalCanvas.width = n;
            finalCanvas.height = totalHeight;

            const ctx = finalCanvas.getContext("2d");

            // èƒŒæ™¯ç™½
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0, 0, n, totalHeight);

            // ç»˜åˆ¶äºŒç»´ç ä¸»ä½“
            ctx.drawImage(qrCanvas, 0, 0);

            // è·å–é™„åŠ ä¿¡æ¯
            const previewImageFile = document.getElementById("previewImageInput").files[0];
            const descriptionText = document.getElementById("descriptionInput").value.trim();

            // è‹¥æ²¡æœ‰æè¿°å›¾ç‰‡ï¼Œåˆ™è®©æ–‡æœ¬å±…ä¸­æ˜¾ç¤º
            if (!previewImageFile) {
                if (descriptionText !== "") {
                    const maxWidth = 0.9 * n;
                    const maxHeight = 0.1 * n;

                    let fontSize = 1;
                    while (true) {
                        ctx.font = `${fontSize + 1}px sans-serif`;
                        const metrics = ctx.measureText(descriptionText);
                        const textHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
                        const textWidth = metrics.width;
                        if (textHeight > maxHeight || textWidth > maxWidth) break;
                        fontSize++;
                    }

                    ctx.font = `${fontSize}px sans-serif`;
                    ctx.fillStyle = "#000";
                    ctx.textBaseline = "middle";
                    ctx.textAlign = "center";
                    ctx.fillText(descriptionText, n / 2, n + extraHeight / 2);
                }

                return finalCanvas;
            }

            return new Promise((resolve) => {
                // æœ‰æè¿°å›¾ç‰‡ â†’ éœ€è¦å¼‚æ­¥åŠ è½½å›¾ç‰‡åç»˜åˆ¶
                const img = new Image();
                const reader = new FileReader();

                reader.onload = function () {
                    img.onload = function () {
                        // æè¿°å›¾ä½ç½®ï¼šå·¦ä¸‹è§’ 0.2n x 0.2n
                        const boxSize = n * 0.2;
                        const boxX = 0;
                        const boxY = n + (extraHeight - boxSize) / 2;

                        let imgW = img.width;
                        let imgH = img.height;
                        const scale = Math.min(boxSize / imgW, boxSize / imgH);
                        imgW *= scale;
                        imgH *= scale;

                        // è®¡ç®—å±…ä¸­ç»˜åˆ¶çš„èµ·ç‚¹
                        const drawX = boxX + (boxSize - imgW) / 2;
                        const drawY = boxY + (boxSize - imgH) / 2;

                        ctx.drawImage(img, drawX, drawY, imgW, imgH);

                        // æè¿°æ–‡å­—ä½ç½®ï¼šå³ä¸‹è§’ 0.7n x 0.1n
                        if (descriptionText !== "") {
                            const boxWidth = n * 0.7;
                            const boxHeight = n * 0.1;
                            const boxX = n * 0.25;
                            const boxY = n + (extraHeight - boxHeight) / 2;

                            let fontSize = 1;
                            while (true) {
                                ctx.font = `${fontSize + 1}px sans-serif`;
                                const metrics = ctx.measureText(descriptionText);
                                const textHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
                                const textWidth = metrics.width;
                                if (textHeight > boxHeight || textWidth > boxWidth) break;
                                fontSize++;
                            }

                            ctx.font = `${fontSize}px sans-serif`;
                            ctx.fillStyle = "#000";
                            ctx.textBaseline = "middle";
                            ctx.textAlign = "left";
                            ctx.fillText(descriptionText, boxX, boxY + boxHeight / 2);
                        }
                        resolve(finalCanvas);
                    };
                    img.src = reader.result;
                };

                reader.readAsDataURL(previewImageFile);
            });
        }
        async function generateDataQRCodeFromFiles(fileList) {
            try {
                // === 0) è¿›åº¦ï¼šå¼€å§‹ ===
                setProgress("encode", 1, "å‡†å¤‡å¼€å§‹â€¦");
                await uiTick();

                // === 1) å‹ç¼©ä¸º zip ===
                setProgress("encode", 4, "å‹ç¼©æ–‡ä»¶â€¦");
                const zipped = await zipFilesAsync(fileList);
                await uiTick();

                // === 2) æ„é€ é€»è¾‘å¤´ + è´Ÿè½½ ===
                const checksum = zipped.reduce((acc, b) => acc ^ b, 0) & 0xff;
                const zippedLength = zipped.length;

                // é€‰æ¨¡å¼
                const mode = document.getElementById("embedMode").value;

                // è¿™ä¸‰é¡¹æ§åˆ¶â€œå®¹é‡ä¼°ç®— / ç‰©ç†å¤´ / ç­–ç•¥æ ‡è®°â€
                let bytesPerPixel = null;       // é anticomp ä½¿ç”¨ï¼ˆä»¥å­—èŠ‚/åƒç´ ä¼°ï¼‰
                let bitsPerPixel = null;        // anticomp ä½¿ç”¨ï¼ˆä»¥æ¯”ç‰¹/åƒç´ ä¼°ï¼‰
                let usePhysicalHeader = true;   // æ˜¯å¦å†™ P0/P1/P2
                let p2StrategyByte = 255;       // ä»…ç‰©ç†å¤´æ—¶ä½¿ç”¨
                let strategyByteInHeader = null;// anticomp æ—¶å†™å…¥é€»è¾‘å¤´

                if (mode === "pair41") {
                    // 2B/åƒç´ ï¼ˆ0..40 ä¸‰ä½ï¼‰
                    bytesPerPixel = 2;
                    usePhysicalHeader = true;
                    p2StrategyByte = 255; // P2.B = 255
                } else if (mode === "byte7") {
                    // 1B/åƒç´ ï¼ˆ0..6 ä¸‰ä½ï¼‰
                    bytesPerPixel = 1;
                    usePhysicalHeader = true;
                    p2StrategyByte = 254; // P2.B = 254
                } else if (mode === "anticomp") {
                    // æ¯åƒç´  2bitï¼ˆç°åº¦ 4 æ¡£ï¼ŒR=G=Bï¼‰
                    bitsPerPixel = 2;
                    usePhysicalHeader = false;
                    strategyByteInHeader = 0xFC; // è¶…æŠ—å‹ç¼©æ ‡è¯†
                }
                else {
                    throw new Error("æœªçŸ¥åµŒå…¥æ¨¡å¼");
                }

                // é€»è¾‘å¤´ä¸æ•°æ®ï¼šé anticomp ä¸º 8 å­—èŠ‚ï¼›anticomp ä¸º 10 å­—èŠ‚ï¼ˆå¤šäº† version/strategyï¼‰
                let fullData, headerLen;
                if (mode === "anticomp") {
                    headerLen = 10;
                    fullData = new Uint8Array(headerLen + zippedLength);
                    fullData[0] = 0x01;                 // version
                    fullData[1] = strategyByteInHeader; // strategy
                    fullData[2] = checksum;             // checksum
                    // [3..5] qrSize ç¨åå›å¡«
                    fullData[6] = (zippedLength >>> 24) & 0xFF;
                    fullData[7] = (zippedLength >>> 16) & 0xFF;
                    fullData[8] = (zippedLength >>> 8) & 0xFF;
                    fullData[9] = zippedLength & 0xFF;
                    fullData.set(zipped, 10);
                } else {
                    headerLen = 8;
                    fullData = new Uint8Array(headerLen + zippedLength);
                    fullData[0] = checksum;
                    // [1..3] qrSize ç¨åå›å¡«
                    fullData[4] = (zippedLength >>> 24) & 0xFF;
                    fullData[5] = (zippedLength >>> 16) & 0xFF;
                    fullData[6] = (zippedLength >>> 8) & 0xFF;
                    fullData[7] = zippedLength & 0xFF;
                    fullData.set(zipped, 8);
                }

                // === 3) è®¡ç®—å°ºå¯¸ ===
                setProgress("encode", 8, "è®¡ç®—å°ºå¯¸ä¸å¤´éƒ¨â€¦");

                let neededPixels;
                if (mode === "anticomp") {
                    // æ¯åƒç´  3bitï¼›éœ€è¦çš„åƒç´  = ceil(æ€»æ¯”ç‰¹ / 3)
                    neededPixels = Math.ceil((fullData.length * 8) / bitsPerPixel);
                } else {
                    // æ¯åƒç´ æŒ‰â€œå­—èŠ‚/åƒç´ â€
                    neededPixels = Math.ceil(fullData.length / bytesPerPixel);
                    // å† +3 ç»™ç‰©ç†å¤´ï¼ˆP0,P1,P2ï¼‰
                    neededPixels += 3;
                }

                let qrSize = Math.ceil(Math.sqrt(neededPixels));
                qrSize = Math.max(512, qrSize);

                // å›å†™ qrSize åˆ°é€»è¾‘å¤´ï¼ˆå¤§ç«¯ï¼‰
                if (mode === "anticomp") {
                    fullData[3] = (qrSize >> 16) & 0xFF;
                    fullData[4] = (qrSize >> 8) & 0xFF;
                    fullData[5] = qrSize & 0xFF;
                } else {
                    fullData[1] = (qrSize >> 16) & 0xFF;
                    fullData[2] = (qrSize >> 8) & 0xFF;
                    fullData[3] = qrSize & 0xFF;
                }
                await uiTick();

                /*console.log("[anticomp-encode] å†™å…¥çš„å¤´éƒ¨ä¿¡æ¯ï¼š");
                console.log("  version =", fullData[0]);
                console.log("  strategy =", fullData[1]);
                console.log("  checksum =", fullData[2]);
                console.log("  qrSize =", (fullData[3] << 16) | (fullData[4] << 8) | fullData[5]);
                console.log("  zipLen =", ((fullData[6] << 24) >>> 0) | (fullData[7] << 16) | (fullData[8] << 8) | fullData[9]);

                // fullData å‰ 30 ä¸ªå­—èŠ‚
                let first30 = [];
                for (let i = 0; i < Math.min(30, fullData.length); i++) {
                    first30.push(fullData[i]);
                }
                console.log("  fullData[0..29] =", first30.join(", "));*/

                // === 4) ç”ŸæˆäºŒç»´ç åº•å›¾ ===
                setProgress("encode", 12, "ç”ŸæˆåŸºç¡€äºŒç»´ç â€¦");
                const canvas = document.createElement("canvas");
                canvas.width = qrSize;
                canvas.height = qrSize;

                // è·å–ç”¨æˆ·é€‰æ‹©çš„é“¾æ¥ï¼Œå¦‚æœé€‰æ‹©è‡ªå®šä¹‰åˆ™ä½¿ç”¨è‡ªå®šä¹‰è¾“å…¥æ¡†çš„å€¼
                const selectedURL = (() => {
                    const select = document.getElementById("qrLinkSelect");
                    if (select.value === "custom") {
                        const customInput = document.getElementById("customLinkInput");
                        return customInput.value.trim() || "https://riluo-ya.github.io/tool/QRepository/";
                    }
                    return select.value;
                })();

                await new Promise((resolve, reject) => {
                    QRCode.toCanvas(
                        canvas,
                        selectedURL,
                        { errorCorrectionLevel: "L", margin: 1, width: qrSize },
                        (err) => (err ? reject(err) : resolve())
                    );
                });
                await uiTick();

                // === 5) å†™å…¥åƒç´  ===
                setProgress("encode", 20, "å†™å…¥æ•°æ®åˆ°åƒç´ â€¦");
                const ctx = canvas.getContext("2d");
                const imgData = ctx.getImageData(0, 0, qrSize, qrSize);
                const px = imgData.data;

                // å·¥å…·ï¼špair41 ä¸ byte7 çš„é€šé“ç¼–ç  + é»‘ç™½æ˜ å°„
                function encodeTwoBytesToThreeBytes(b1, b2) {
                    let v = ((b1 & 0xFF) << 8) | (b2 & 0xFF);
                    const c3 = v % 41; v = Math.floor(v / 41);
                    const c2 = v % 41; v = Math.floor(v / 41);
                    const c1 = v; // 0..40
                    return [c1, c2, c3];
                }
                function encodeByteToRGB7(b) {
                    let v = b & 0xFF;
                    const c3 = v % 7; v = Math.floor(v / 7);
                    const c2 = v % 7; v = Math.floor(v / 7);
                    const c1 = v; // 0..6
                    return [c1, c2, c3];
                }
                const writeCh = (orig, v) => (orig < 128 ? v : 255 - v);

                // â€”â€” anticomp çš„ 2bit ç°åº¦å†™å…¥ï¼šæ¯åƒç´  2bitï¼ŒR=G=B â€”â€” //
                const LEVELS = [0, 30, 60, 90];    // é»‘ä¾§ 4 æ¡£
                const isWhite = (v) => v >= 128;

                // ä»ç¼“å†²æŒ‰ MSB-first å– 2bitï¼Œè¶Šç•Œåˆ™å³ä¾§è¡¥ 0
                function get2BitsPad(buf, bitIndex, totalBits) {
                    const b0 = (bitIndex < totalBits)
                        ? ((buf[bitIndex >>> 3] >>> (7 - (bitIndex & 7))) & 1) : 0;
                    const b1 = (bitIndex + 1 < totalBits)
                        ? ((buf[(bitIndex + 1) >>> 3] >>> (7 - ((bitIndex + 1) & 7))) & 1) : 0;
                    return (b0 << 1) | b1; // 0..3
                }

                // ä¾æ®äºŒç»´ç åº•è‰²ï¼ˆé»‘/ç™½ï¼‰æŠŠ 2bit æ˜ å°„ä¸ºç°åº¦ï¼šé»‘ä¾§ 0/30/60/90ï¼›ç™½ä¾§ 255-è¿™äº›å€¼
                function write2BitsGray(origR, origG, origB, twoBits) {
                    // ç”¨åŸåƒç´ äº®åº¦åˆ¤æ–­æ˜¯é»‘å—è¿˜æ˜¯ç™½å—ï¼ˆR/G/B åœ¨ QR èƒŒæ™¯é‡ŒåŸºæœ¬ä¸€è‡´ï¼‰
                    const lum = (origR + origG + origB) / 3;
                    const base = LEVELS[twoBits & 3];
                    const v = (lum >= 128) ? (255 - base) : base;
                    return v & 0xFF;
                }

                // ç‰©ç†å¤´ï¼ˆä»… pair41/byte7 ä½¿ç”¨ï¼‰
                if (usePhysicalHeader) {
                    // P0 = (250,251,252) @ (0,0)
                    let i0 = 0 * 4;
                    px[i0] = 250; px[i0 + 1] = 251; px[i0 + 2] = 252; px[i0 + 3] = 255;

                    // P1 = (253,254,255) @ (1,0)
                    let i1 = 1 * 4;
                    px[i1] = 253; px[i1 + 1] = 254; px[i1 + 2] = 255; px[i1 + 3] = 255;

                    // P2 = (255,255, strategy) @ (2,0)
                    let i2 = 2 * 4;
                    px[i2] = 255; px[i2 + 1] = 255; px[i2 + 2] = p2StrategyByte; px[i2 + 3] = 255;
                }

                const totalBytes = fullData.length;
                const totalBits = totalBytes * 8;

                // è¿›åº¦æ¡ï¼šæ•°æ®ä½æ¨è¿›ï¼ˆåªæŒ‰çœŸå®æ•°æ®æ¨è¿›ï¼‰
                const startPct = 20, endPct = 92, pctSpan = endPct - startPct;
                let advanceUnit = mode === "anticomp" ? totalBits : totalBytes;
                let progressed = 0, lastReport = 0;
                const report = () => {
                    const now = progressed;
                    if (now - lastReport >= 8192 || now === advanceUnit) {
                        lastReport = now;
                        const frac = now / advanceUnit;
                        const pct = startPct + Math.floor(frac * pctSpan);
                        setProgress("encode", pct,
                            mode === "anticomp"
                                ? `å†™å…¥æ•°æ®ä½â€¦ (${now}/${advanceUnit} bit)`
                                : `å†™å…¥æ•°æ®â€¦ (${now}/${advanceUnit} å­—èŠ‚)`
                        );
                    }
                };

                if (mode === "anticomp") {
                    // â€”â€” æ¯åƒç´  2bitï¼ŒR=G=Bï¼›ä» (0,0) æŒ‰è¡Œå†™æ»¡ â€”â€” //
                    let bitIndex = 0;                // æŒ‡å‘ fullData çš„ä½åç§»ï¼ˆMSB-firstï¼‰
                    for (let y = 0; y < qrSize; y++) {
                        for (let x = 0; x < qrSize; x++) {
                            const idx = (y * qrSize + x) * 4;

                            // å–å½“å‰åº•å›¾åƒç´ ï¼ˆäºŒç»´ç é»‘ç™½ï¼‰ä»¥å†³å®šåº”ç”¨é»‘ä¾§/ç™½ä¾§ç°åº¦
                            const origR = px[idx], origG = px[idx + 1], origB = px[idx + 2];

                            let twoBits;
                            if (bitIndex < totalBits) {
                                twoBits = get2BitsPad(fullData, bitIndex, totalBits);
                                const advance = Math.min(2, totalBits - bitIndex);
                                bitIndex += advance;
                                progressed += advance;   // è¿›åº¦ä»¥â€œä½â€ä¸ºå•ä½
                                report();
                            } else {
                                // æ•°æ®å†™å®Œåï¼Œç”¨éšæœº 2bit å¡«å……ï¼ˆä¸æ¨è¿›è¿›åº¦ï¼‰
                                twoBits = (Math.random() * 4) | 0; // 0..3
                            }

                            const gray = write2BitsGray(origR, origG, origB, twoBits);
                            px[idx] = gray;
                            px[idx + 1] = gray;
                            px[idx + 2] = gray;
                            px[idx + 3] = 255; // ä¸é€æ˜
                        }
                        if ((y & 7) === 0) await uiTick();
                    }
                } else {
                    // â€”â€” pair41/byte7 å†™å…¥ï¼Œä»(3,0)å¼€å§‹ â€”â€” //
                    let dataIndex = 0;
                    for (let y = 0; y < qrSize; y++) {
                        for (let x = 0; x < qrSize; x++) {
                            // è·³è¿‡ç‰©ç†å¤´ä¸‰åƒç´ 
                            if (y === 0 && (x === 0 || x === 1 || x === 2)) continue;
                            const idx = (y * qrSize + x) * 4;

                            let c1, c2, c3;
                            if (dataIndex < totalBytes) {
                                if (bytesPerPixel === 2) {
                                    const b1 = fullData[dataIndex++] ?? 0;
                                    const b2 = fullData[dataIndex++] ?? 0;
                                    [c1, c2, c3] = encodeTwoBytesToThreeBytes(b1, b2);
                                } else {
                                    const b = fullData[dataIndex++] ?? 0;
                                    [c1, c2, c3] = encodeByteToRGB7(b);
                                }
                                progressed = dataIndex;
                                report();
                            } else {
                                // éšæœºå¡«å……åœ¨å¯ç”¨èŒƒå›´å†…ï¼ˆä¸æ¨è¿›è¿›åº¦ï¼‰
                                if (bytesPerPixel === 2) {
                                    c1 = (Math.random() * 41) | 0;
                                    c2 = (Math.random() * 41) | 0;
                                    c3 = (Math.random() * 41) | 0;
                                } else {
                                    c1 = (Math.random() * 7) | 0;
                                    c2 = (Math.random() * 7) | 0;
                                    c3 = (Math.random() * 7) | 0;
                                }
                            }

                            // é»‘/ç™½æ˜ å°„
                            px[idx] = writeCh(px[idx], c1);
                            px[idx + 1] = writeCh(px[idx + 1], c2);
                            px[idx + 2] = writeCh(px[idx + 2], c3);
                            px[idx + 3] = 255;
                        }
                        if ((y & 7) === 0) await uiTick();
                    }
                }

                setProgress("encode", 92, "å†™å…¥å®Œæˆï¼Œæ”¶å°¾ä¸­â€¦");
                ctx.putImageData(imgData, 0, 0);

                // === 6) åˆæˆé¢„è§ˆ & å¯¼å‡º ===
                setProgress("encode", 94, "åˆæˆå±•ç¤ºâ€¦");
                await uiTick();

                const preview = document.getElementById("qrPreviewContainer");
                preview.innerHTML = "";

                const composed = await composeFinalQRCodeCanvas(canvas);
                preview.appendChild(composed);

                const displayWidth = 300;
                const ratio = composed.height / composed.width;
                composed.style.width = `${displayWidth}px`;
                composed.style.height = `${displayWidth * ratio}px`;
                composed.style.display = "block";
                composed.style.margin = "10px auto";

                const link = document.getElementById("downloadLink");
                link.style.display = "none";

                setProgress("encode", 96, "æ­£åœ¨ç¼–ç  PNGâ€¦");
                await uiTick();

                composed.toBlob((blob) => {
                    if (!blob) { alert("PNG ç¼–ç å¤±è´¥"); hideProgress("encode", "å¤±è´¥"); return; }
                    const url = URL.createObjectURL(blob);
                    link.href = url;
                    link.download = "qr_encoded.png";
                    link.style.display = "inline-block";
                    link.onclick = () => setTimeout(() => URL.revokeObjectURL(url), 2000);
                    hideProgress("encode", "å®Œæˆ");
                }, "image/png");
            } catch (err) {
                console.error(err);
                alert(`ç¼–ç å¤±è´¥ï¼š${err.message || err}`);
                hideProgress("encode", "å¤±è´¥");
            }
        }

        function switchTab(mode) {
            const decoderButton = document.getElementById("extractTab");
            const encoderButton = document.getElementById("embedTab");

            const decoderSection = document.getElementById("decoder");
            const encoderSection = document.getElementById("encoder");

            if (mode === "decoder") {
                decoderButton.classList.add("active");
                encoderButton.classList.remove("active");

                decoderSection.classList.add("active");
                encoderSection.classList.remove("active");
            } else if (mode === "encoder") {
                encoderButton.classList.add("active");
                decoderButton.classList.remove("active");

                encoderSection.classList.add("active");
                decoderSection.classList.remove("active");
            }
        }

        document.getElementById("decodeButton").onclick = async function () {
            const input = document.getElementById("imageInput");
            const file = input.files && input.files[0];
            if (!file) {
                alert("è¯·å…ˆé€‰æ‹©äºŒç»´ç å›¾ç‰‡");
                return;
            }

            const button = document.getElementById("decodeButton");
            button.disabled = true;
            const originalText = button.innerText;
            button.innerText = "å¤„ç†ä¸­â€¦";

            try {
                await decodeQRCode(file, button, originalText);
            } catch (err) {
                console.error(err);
                alert("å¤„ç†å¤±è´¥ï¼š" + err.message);
                // å‡ºé”™æ—¶è¿™é‡Œå¯ä»¥å…œåº•æ¢å¤æŒ‰é’®
                button.disabled = false;
                button.innerText = originalText;
            }
        };

        async function decodeQRCode(file, button, originalText) {
            const cancel = (msg) => { if (msg) alert(msg); hideProgress("decode", "å·²å–æ¶ˆ"); };
            const finish = (msg) => hideProgress("decode", msg || "å®Œæˆ");

            let lastStrategy = null;
            const workerSrc = `
self.onmessage = async (e) => {
  const msg = e.data || {};
  if (msg.type !== 'scan') return;

  // --- å¸¸é‡ä¸å°å·¥å…· ---
  const P0 = [250,251,252];
  const P1 = [253,254,255];
  const STRAT_PAIR41 = 255; // 2B/åƒç´ ï¼ˆ41è¿›åˆ¶ï¼‰
  const STRAT_BYTE7  = 254; // 1B/åƒç´ ï¼ˆ7è¿›åˆ¶ï¼‰

  const readCh = (ch) => (ch > 128) ? (255 - ch) : ch;

  function decodeThreeBytesToTwoBytes(c1, c2, c3) {
    if (c1<0||c1>40||c2<0||c2>40||c3<0||c3>40) return null;
    const v = c1*41*41 + c2*41 + c3;
    return [(v>>8)&0xFF, v&0xFF];
  }
  function decodeRGB7ToByte(c1, c2, c3) {
    if (c1<0||c1>6||c2<0||c2>6||c3<0||c3>6) return null;
    return (c1*49)+(c2*7)+c3;
  }

  function* headerCandidates(px, width, height) {
    // æ•´å›¾æ‰«æè¿ç»­ä¸‰åƒç´ ï¼šP0, P1, P2(255,255,ç­–ç•¥)
    for (let y=0; y<height; y++) {
      for (let x=0; x<=width-3; x++) {
        const i0=(y*width+x)*4, i1=i0+4, i2=i1+4;
        if (px[i0]===P0[0] && px[i0+1]===P0[1] && px[i0+2]===P0[2] &&
            px[i1]===P1[0] && px[i1+1]===P1[1] && px[i1+2]===P1[2] &&
            px[i2]===255   && px[i2+1]===255   && (px[i2+2]===STRAT_PAIR41 || px[i2+2]===STRAT_BYTE7)) {
          yield { ox:x, oy:y, strategy:px[i2+2] };
        }
      }
    }
  }

  try {
    const { width, height, pixelsBuf } = msg;
    const px = new Uint8ClampedArray(pixelsBuf);

    let tried = 0;
    for (const cand of headerCandidates(px, width, height)) {
      tried++;

      // â€”â€”â€” 1) ç¡®å®šç­–ç•¥ä¸åƒç´ è¯»å–æ¸¸æ ‡ â€”â€”â€”
      const bytesPerPixel = (cand.strategy === STRAT_PAIR41) ? 2 : 1;
      let curX = cand.ox + 3, curY = cand.oy; // æ•°æ®èµ·ç‚¹

      const nextPixelIdx = (limitW, limitH) => {
        const maxW = limitW ?? width;
        const maxH = limitH ?? height;
        if (curY >= maxH) return -1;
        if (curX >= maxW) { curX = (limitW ? cand.ox : 0); curY++; }
        if (curY >= maxH) return -1;
        const idx = (curY*width + curX) * 4;
        curX++;
        return idx;
      };

      // â€”â€”â€” 2) è¯»å– 8 å­—èŠ‚é€»è¾‘å¤´ï¼ˆä¸é™åˆ¶åŒºåŸŸï¼Œé€šå¸¸ä»åœ¨å†…å®¹åŒºï¼‰â€”â€”â€”
      const head = new Uint8Array(8);
      let hpos = 0;
      let headerRangeError = false;

      while (hpos < 8) {
        const idx = nextPixelIdx(); // æš‚ä¸é™åˆ¶åŒºåŸŸ
        if (idx < 0) { headerRangeError = true; break; }
        const c1 = readCh(px[idx]), c2 = readCh(px[idx+1]), c3 = readCh(px[idx+2]);
        if (bytesPerPixel === 2) {
          const pair = decodeThreeBytesToTwoBytes(c1, c2, c3);
          if (!pair) { headerRangeError = true; break; }
          head[hpos++] = pair[0];
          if (hpos < 8) head[hpos++] = pair[1];
        } else {
          const b = decodeRGB7ToByte(c1, c2, c3);
          if (b == null) { headerRangeError = true; break; }
          head[hpos++] = b;
        }
      }
      if (headerRangeError) {
        // å½“å‰å€™é€‰å¤´å¤±è´¥ï¼Œå°è¯•ä¸‹ä¸€ä¸ª
        self.postMessage({ type:'retry', reason:'å¤´éƒ¨è§£æå¤±è´¥ï¼Œå°è¯•ä¸‹ä¸€ä¸ªæ–‡ä»¶å¤´â€¦', tried });
        continue;
      }

      const checksum = head[0] | 0;
      const qrSize = ((head[1]<<16)|(head[2]<<8)|head[3])>>>0;
      const zippedLength = (((head[4]<<24)>>>0)|(head[5]<<16)|(head[6]<<8)|head[7])>>>0;
      const needTotal = 8 + zippedLength;

      // æŠŠå¤´å‘ç»™ä¸»çº¿ç¨‹ï¼Œè®©å…¶åš >50MB ç¡®è®¤
      let proceed = true;
      self.postMessage({ type:'head', qrSize, zippedLength, strategy: cand.strategy, tried });

      proceed = await new Promise(res=>{
        const h=(ev)=>{ if (ev.data && ev.data.type==='head-ack') { self.removeEventListener('message',h); res(!!ev.data.proceed); } };
        self.addEventListener('message', h);
      });
      if (!proceed) { self.postMessage({ type:'cancelled' }); return; }

      // â€”â€”â€” 3) é™å®šè¯»å–çª—å£ï¼Œè¯»å–å‰©ä½™æ•°æ®å¹¶å®æ—¶è®¡ç®— XOR â€”â€”â€”
      const limitW = Math.min(width,  cand.ox + qrSize);
      const limitH = Math.min(height, cand.oy + qrSize);

      const fullData = new Uint8Array(needTotal);
      fullData.set(head, 0);
      let pos = 8;

      let calcXor = 0; // ä»…å¯¹ zipped éƒ¨åˆ†è®¡ç®—
      let lastReport = 0;
      const report = () => {
        if (pos - lastReport >= 10000 || pos >= needTotal) {
          lastReport = pos;
          self.postMessage({ type:'progress', got: pos, total: needTotal, tried });
        }
      };

      let outOfPixels = false;
      while (pos < needTotal) {
        const idx = nextPixelIdx(limitW, limitH);
        if (idx < 0) { outOfPixels = true; break; }
        const c1 = readCh(px[idx]), c2 = readCh(px[idx+1]), c3 = readCh(px[idx+2]);
        if (bytesPerPixel === 2) {
          const pair = decodeThreeBytesToTwoBytes(c1, c2, c3);
          if (!pair) { outOfPixels = true; break; }
          if (pos < needTotal) { fullData[pos] = pair[0]; calcXor ^= pair[0]; pos++; }
          if (pos < needTotal) { fullData[pos] = pair[1]; calcXor ^= pair[1]; pos++; }
        } else {
          const b = decodeRGB7ToByte(c1, c2, c3);
        if (b == null) { outOfPixels = true; break; }
          fullData[pos] = b; calcXor ^= b; pos++;
        }
        report();
      }
      if (outOfPixels || pos < needTotal) {
        self.postMessage({ type:'retry', reason:'åƒç´ ä¸è¶³æˆ–æ•°æ®è¯»å¤±è´¥ï¼Œå°è¯•ä¸‹ä¸€ä¸ªæ–‡ä»¶å¤´â€¦', tried });
        continue; // ä¸‹ä¸€ä¸ªå€™é€‰å¤´
      }

      // â€”â€”â€” 4) æ ¡éªŒ XOR â€”â€”â€”
      if ((calcXor & 0xFF) !== checksum) {
        // è¿™ä¸ªå€™é€‰å¤´æ ¡éªŒä¸é€šè¿‡ï¼Œè‡ªåŠ¨å°è¯•ä¸‹ä¸€ä¸ª
        self.postMessage({ type:'retry', reason:'æ ¡éªŒå¤±è´¥ï¼Œå°è¯•ä¸‹ä¸€ä¸ªæ–‡ä»¶å¤´â€¦', tried, calc: (calcXor & 0xFF), checksum });
        continue;
      }

      // æˆåŠŸ
      self.postMessage({ type:'done', fullData: fullData.buffer }, [fullData.buffer]);
      return;
    }

    // æ²¡æœ‰ä»»ä½•å€™é€‰å¤´æˆåŠŸ
    const STRAT_ANTICOMP = 0xFC;
    const LEVELS = [0, 30, 60, 90]; // é»‘ä¾§ç°åº¦æ¡£

    // å°†å•ä¸ªç°åº¦å€¼æ˜ å°„å› 2bitï¼šæ‰¾ç¦» 0/30/60/90 æˆ– 255-è¿™äº› å€¼â€œæœ€è¿‘â€çš„æ¡£ä½
    function twoBitsFromGray(g) {
        // å…ˆæ˜ å°„åˆ°â€œé»‘ä¾§â€èŒƒå›´ï¼Œç™½ä¾§å°±ç¿»è½¬åˆ°é»‘ä¾§
        if (g > 127) g = 255 - g;
        // å› ä¸ºæ¡£ä½æ˜¯ 0,30,60,90ï¼Œæ‰€ä»¥ç›´æ¥é™¤ä»¥ 30
        let idx = Math.round(g / 30); // å¾—åˆ° 0~3
        // é™åˆ¶èŒƒå›´ï¼ˆé˜²æ­¢å‹ç¼©åå·®å¯¼è‡´è¶Šç•Œï¼‰
        if (idx < 0) idx = 0;
        if (idx > 3) idx = 3;
        return idx; // 0..3  => 00, 01, 10, 11
    }

    // ç”Ÿæˆä½æµï¼šæŒ‰è¡Œæ‰«ææ•´å¼ å›¾ï¼›æ¯åƒç´  2bitï¼ˆR=G=Bï¼‰ï¼ŒMSB-first è¾“å‡ºä¸¤ä½
    function* bitStream(px, width, height) {
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
            const idx = (y * width + x) * 4;
            // ç”¨ä¸‰é€šé“å¹³å‡åšé²æ£’ç°åº¦ï¼ˆR/G/B ç†è®ºä¸Šç›¸ç­‰ï¼Œä½†å‹ç¼©åæœ‰è½»å¾®åå·®ï¼‰
            const gray = Math.round((px[idx] + px[idx + 1] + px[idx + 2]) / 3);
            const val2 = twoBitsFromGray(gray); // 0..3
            // è¾“å‡ºé«˜ä½â†’ä½ä½
            yield (val2 >> 1) & 1;
            yield val2 & 1;
            }
        }
    }

    // ä»ä½æµä¸­è¯»å– n ä½
    function readBitsToBytes(bits, nBits) {
        const arr = [];
        let cur = 0, have = 0, read = 0;
        for (const b of bits) {
            cur = (cur << 1) | (b & 1);
            have++; read++;
            if (have === 8) { arr.push(cur); cur = 0; have = 0; }
            if (read === nBits) break;
        }
        if (have > 0) arr.push((cur << (8 - have)) & 0xFF);
        return new Uint8Array(arr);
    }

    function readBitsToFixedBuffer(bits, nBits, target) {
        let cur = 0, have = 0, bi = 0, wrote = 0;
        for (const b of bits) {
            cur = (cur << 1) | (b & 1);
            have++;
            if (have === 8) {
            if (bi < target.length) target[bi++] = cur;
            wrote++; cur = 0; have = 0;
            if (wrote * 8 >= nBits) break;
            }
        }
        if (have > 0 && bi < target.length) target[bi++] = (cur << (8 - have)) & 0xFF;
        return bi;
    }

    // â€”â€” å…ˆè¯» 10B å¤´ï¼ˆ80 bitï¼‰â€”â€”
    const bits = bitStream(px, width, height);
    const headBytes = readBitsToBytes(bits, 80); // 10B
    if (headBytes.length < 10) throw new Error("è¶…æŠ—å‹ç¼©ï¼šä½æµä¸è¶³ï¼Œæ— æ³•è¯»å–å¤´éƒ¨");

    const version  = headBytes[0] | 0;
    const strategy = headBytes[1] | 0;
    const checksum = headBytes[2] | 0;
    const qrSize   = ((headBytes[3] << 16) | (headBytes[4] << 8) | headBytes[5]) >>> 0;
    const zipLen   = (((headBytes[6] << 24) >>> 0) | (headBytes[7] << 16) | (headBytes[8] << 8) | headBytes[9]) >>> 0;

    if (version !== 0x01 || strategy !== STRAT_ANTICOMP) {
        throw new Error("è¶…æŠ—å‹ç¼©ï¼šå¤´éƒ¨ version/strategy ä¸åŒ¹é…ï¼ˆä¸æ˜¯ è¶…æŠ—å‹ç¼© æ•°æ®ï¼‰");
    }

    // ä¸»çº¿ç¨‹å®¹é‡ç¡®è®¤
    self.postMessage({ type: 'head', qrSize, zippedLength: zipLen, strategy: STRAT_ANTICOMP, tried: -1 });
        const proceed = await new Promise(res => {
        const h = (ev) => { if (ev.data && ev.data.type === 'head-ack') { self.removeEventListener('message', h); res(!!ev.data.proceed); } };
        self.addEventListener('message', h);
    });
    if (!proceed) { self.postMessage({ type: 'cancelled' }); return; }

    // â€”â€” è¯»å–å…¨éƒ¨æ•°æ®ï¼š10B å¤´ + zipLen â€”â€”
    // æ³¨æ„ï¼šä½æµä»å¤´å¼€å§‹é‡æ–°ç”Ÿæˆ
    const totalBytes = 10 + zipLen;
    const totalBits  = totalBytes * 8;

    const bits2 = bitStream(px, width, height);
    const fullData = new Uint8Array(totalBytes);
    const filled = readBitsToFixedBuffer(bits2, totalBits, fullData);
    if (filled < totalBytes) throw new Error("è¶…æŠ—å‹ç¼©ï¼šåƒç´ ä½æ•°ä¸è¶³ï¼Œæ— æ³•è¯»å–å®Œæ•´æ•°æ®");

    // XOR æ ¡éªŒï¼ˆä»… zipData éƒ¨åˆ†ï¼‰
    let calc = 0;
    for (let i = 10; i < totalBytes; i++) calc ^= fullData[i];
    calc &= 0xFF;

    if (calc !== checksum) {
    throw new Error(\`è¶…æŠ—å‹ç¼©ï¼šæ ¡éªŒå¤±è´¥ï¼ˆé¢„æœŸ \${checksum}ï¼Œå®é™… \${calc}ï¼‰ã€‚\`);
    }

    // æˆåŠŸ
    self.postMessage({ type: 'done', fullData: fullData.buffer }, [fullData.buffer]);
    return;
    } catch (e) {
        // ä»å¤±è´¥ï¼Œç»™å‡ºç»Ÿä¸€é”™è¯¯
        self.postMessage({ type:'error', message: (e && e.message) ? \`è§£æå¤±è´¥ï¼å›¾åƒå¯èƒ½ç»è¿‡å°ºå¯¸å‹ç¼©ï¼Œæˆ–è€…åœ¨æœªé€‰æ‹©è¶…æŠ—å‹ç¼©æ¨¡å¼çš„æƒ…å†µä¸‹å—åˆ°äº†ç”»è´¨å‹ç¼©ã€‚è¯·å°è¯•è·å–åŸå›¾é‡è¯•ã€‚\\n\\né”™è¯¯è¯¦æƒ…ï¼š\${e.message}\` : 'è§£æå¤±è´¥ï¼å›¾åƒå¯èƒ½ç»è¿‡å°ºå¯¸å‹ç¼©ï¼Œæˆ–è€…åœ¨æœªé€‰æ‹©è¶…æŠ—å‹ç¼©æ¨¡å¼çš„æƒ…å†µä¸‹å—åˆ°äº†ç”»è´¨å‹ç¼©ã€‚è¯·å°è¯•è·å–åŸå›¾é‡è¯•ã€‚' });
    }
};
`;

            const worker = new Worker(URL.createObjectURL(new Blob([workerSrc], { type: 'application/javascript' })));

            const url = URL.createObjectURL(file);
            let bitmap;
            try {
                bitmap = await createImageBitmap(file, { imageOrientation: 'none', premultiplyAlpha: 'none', colorSpaceConversion: 'none' });
            } catch {
                bitmap = null;
            }

            const drawAndScan = async () => {
                try {
                    setProgress("decode", 1, "è¯»å–å›¾åƒåƒç´ â€¦");
                    await uiTick();

                    const canvas = document.createElement("canvas");
                    const ctx = canvas.getContext("2d", { willReadFrequently: true });
                    let width, height;

                    if (bitmap) {
                        width = canvas.width = bitmap.width;
                        height = canvas.height = bitmap.height;
                        ctx.imageSmoothingEnabled = false;
                        ctx.drawImage(bitmap, 0, 0);
                    } else {
                        const img = new Image();
                        img.src = url;
                        await new Promise((res, rej) => { img.onload = () => res(); img.onerror = () => rej(new Error("å›¾ç‰‡åŠ è½½å¤±è´¥")); });
                        width = canvas.width = img.naturalWidth || img.width;
                        height = canvas.height = img.naturalHeight || img.height;
                        ctx.imageSmoothingEnabled = false;
                        ctx.drawImage(img, 0, 0);
                    }

                    const imgData = ctx.getImageData(0, 0, width, height);
                    const buf = imgData.data.buffer;

                    worker.onmessage = async (ev) => {
                        const m = ev.data || {};
                        if (m.type === 'head') {
                            const { qrSize, zippedLength, strategy } = m;
                            lastStrategy = strategy;
                            if (zippedLength > 50 * 1024 * 1024) {
                                const proceed = confirm(`âš ï¸ æ•°æ®å¤§å°ä¸º ${formatBytes(zippedLength)}ï¼Œå¯èƒ½åŠ è½½ç¼“æ…¢æˆ–å¤±è´¥ã€‚\næ˜¯å¦ä»è¦ç»§ç»­ï¼Ÿ`);
                                worker.postMessage({ type: 'head-ack', proceed });
                                if (!proceed) {
                                    worker.terminate();
                                    URL.revokeObjectURL(url);
                                    cancel("ç”¨æˆ·å–æ¶ˆäº†è§£ç ã€‚");
                                    if (button) { button.disabled = false; button.innerText = originalText; }
                                    return;
                                }
                            } else {
                                worker.postMessage({ type: 'head-ack', proceed: true });
                            }
                        } else if (m.type === 'retry') {
                            // å¯é€‰ï¼šæ˜¾ç¤ºæ­£åœ¨å°è¯•ä¸‹ä¸€ä¸ªå¤´çš„æç¤º
                            setProgress("decode", 12, m.reason || "å°è¯•ä¸‹ä¸€ä¸ªæ–‡ä»¶å¤´â€¦");
                        } else if (m.type === 'progress') {
                            const p = 8 + Math.floor((m.got / m.total) * 62); // 8%~70%
                            setProgress("decode", p, `æ‰«ææ•°æ®â€¦ (${m.got}/${m.total} å­—èŠ‚)`);
                        } else if (m.type === 'error') {
                            worker.terminate(); URL.revokeObjectURL(url);
                            alert('æå–å¤±è´¥ï¼š' + m.message);
                            hideProgress("decode", "å¤±è´¥");
                            if (button) { button.disabled = false; button.innerText = originalText; }
                        } else if (m.type === 'cancelled') {
                            worker.terminate(); URL.revokeObjectURL(url);
                            cancel("ç”¨æˆ·å–æ¶ˆäº†è§£ç ã€‚");
                            if (button) { button.disabled = false; button.innerText = originalText; }
                        } else if (m.type === 'done') {
                            worker.terminate(); URL.revokeObjectURL(url);

                            const fullData = new Uint8Array(m.fullData);
                            const checksum = fullData[0];
                            const headerLen = (lastStrategy === 0xFC) ? 10 : 8;
                            const zippedData = fullData.slice(headerLen);

                            // Worker å·²ä¿è¯é€šè¿‡æ ¡éªŒï¼Œè¿™é‡Œä¸å†äºŒæ¬¡ç¡®è®¤
                            setProgress("decode", 80, "è§£å‹ä¸­â€¦");
                            await uiTick();

                            fflate.unzip(zippedData, async (err, files) => {
                                if (err) {
                                    alert('è§£å‹å¤±è´¥ï¼š' + (err.message || err));
                                    hideProgress("decode", "å¤±è´¥");
                                    if (button) { button.disabled = false; button.innerText = originalText; }
                                    return;
                                }

                                const list = document.getElementById("fileList");
                                list.innerHTML = "";

                                const names = Object.keys(files);
                                if (names.length === 0) {
                                    list.textContent = "ï¼ˆè§£å‹æˆåŠŸï¼Œä½†å‹ç¼©åŒ…ä¸ºç©ºï¼‰";
                                    finish();
                                    if (button) { button.disabled = false; button.innerText = originalText; }
                                    return;
                                }

                                const totalSize = names.reduce((s, n) => s + (files[n]?.length || 0), 0);
                                const summary = document.createElement("div");
                                summary.style.textAlign = "center";
                                summary.innerHTML = `ğŸ“ å…± ${names.length} ä¸ªæ–‡ä»¶<br>ğŸ“ è§£å‹åå¤§å°ï¼š${formatBytes(totalSize)}<br><br>`;
                                list.appendChild(summary);

                                // ä¸‹è½½ ZIP
                                const zipBlob = new Blob([zippedData], { type: "application/zip" });
                                const zipA = document.createElement("a");
                                zipA.href = URL.createObjectURL(zipBlob);
                                zipA.download = "qr_extracted.zip";
                                zipA.textContent = "ğŸ“¦ ä¸‹è½½æ•´ä¸ª ZIP";
                                Object.assign(zipA.style, {
                                    display: "inline-block", margin: "10px", padding: "10px",
                                    background: "#1976d2", color: "#fff", borderRadius: "6px", textDecoration: "none"
                                });
                                zipA.onclick = () => setTimeout(() => URL.revokeObjectURL(zipA.href), 2000);

                                // åˆ†å¼€ä¸‹è½½ï¼ˆåˆ†æ‰¹ï¼‰
                                const splitBtn = document.createElement("button");
                                splitBtn.textContent = "ğŸ“‚ åˆ†å¼€ä¸‹è½½å…¨éƒ¨æ–‡ä»¶";
                                Object.assign(splitBtn.style, {
                                    margin: "10px", padding: "10px", background: "#43a047",
                                    color: "#fff", border: "none", borderRadius: "6px", cursor: "pointer"
                                });
                                splitBtn.onclick = async () => {
                                    const batch = 10;
                                    for (let i = 0; i < names.length; i += batch) {
                                        const slice
                                        = names.slice(i, i + batch);
                                        setProgress("decode", 96, `é€ä¸ªä¸‹è½½â€¦ (${Math.min(i + batch, names.length)}/${names.length})`);
                                        for (const name of slice) {
                                            const blob = new Blob([files[name]]);
                                            const a = document.createElement("a");
                                            a.href = URL.createObjectURL(blob);
                                            a.download = name;
                                            a.style.display = "none";
                                            document.body.appendChild(a);
                                            a.click();
                                            document.body.removeChild(a);
                                            setTimeout(() => URL.revokeObjectURL(a.href), 2000);
                                        }
                                        await uiTick();
                                    }
                                    finish();
                                    if (button) { button.disabled = false; button.innerText = originalText; }
                                };

                                list.appendChild(zipA);
                                list.appendChild(splitBtn);
                                finish();
                                if (button) { button.disabled = false; button.innerText = originalText; }
                            });
                        }
                    };

                    setProgress("decode", 8, "æ‰«æäºŒç»´ç æ•°æ®â€¦");
                    worker.postMessage({ type: 'scan', width, height, pixelsBuf: buf }, [buf]);
                } catch (err) {
                    alert(`æå–å¤±è´¥ï¼š${err.message}`);
                    hideProgress("decode", "å¤±è´¥");
                    try { worker.terminate(); } catch { }
                    URL.revokeObjectURL(url);
                    if (button) { button.disabled = false; button.innerText = originalText; }
                }
            };

            await drawAndScan();
        }

        // è¾…åŠ©ï¼šå­—èŠ‚è½¬å‹å¥½å•ä½
        function formatBytes(n) {
            if (!Number.isFinite(n)) return n + " B";
            const units = ["B", "KB", "MB", "GB"];
            let i = 0;
            while (n >= 1024 && i < units.length - 1) {
                n /= 1024;
                i++;
            }
            return n.toFixed(n < 10 && i > 0 ? 1 : 0) + " " + units[i];
        }

        window.onload = () => {
            const status = document.getElementById("status");
            const loaded = typeof fflate !== "undefined" && typeof QRCode !== "undefined";

            if (loaded) {
                status.textContent = "ğŸŸ¢ æ‰€æœ‰ä¾èµ–åŠ è½½æˆåŠŸï¼Œå¯æ–­ç½‘ä½¿ç”¨";
                status.style.color = "limegreen";
            } else {
                status.textContent = "ğŸ”´ ä¾èµ–åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥";
                status.style.color = "red";
            }

            // æ§åˆ¶é™„åŠ æè¿°å›¾ç‰‡å’Œæè¿°çš„æ˜¾ç¤º
            document.getElementById("extraInfoToggle").onchange = (e) => {
                document.getElementById("extraInfoContainer").style.display = e.target.checked ? "block" : "none";
            };

            // æ–‡ä»¶åæ˜¾ç¤ºï¼šä¸Šä¼ æ–‡ä»¶ç»„
            const filesInput = document.getElementById("filesInput");
            filesInput.onchange = () => {
                const files = [...filesInput.files];
                const count = files.length;

                let displayText = "æœªé€‰æ‹©ä»»ä½•æ–‡ä»¶";
                if (count === 1) {
                    displayText = `${files[0].name}ï¼ˆå…± 1 ä¸ªæ–‡ä»¶ï¼‰`;
                } else if (count === 2) {
                    displayText = `${files[0].name}, ${files[1].name}ï¼ˆå…± 2 ä¸ªæ–‡ä»¶ï¼‰`;
                } else if (count > 2) {
                    displayText = `${files[0].name}, ${files[1].name} ç­‰ ${count} ä¸ªæ–‡ä»¶`;
                }

                document.getElementById("filesInputName").textContent = displayText;
            };


            const imageInputName = document.getElementById("imageInputName");
            const imageInput = document.getElementById("imageInput");

            // é€‰æ‹©åæ›´æ–°æ–‡ä»¶å
            imageInput.onchange = () => {
                const name = imageInput.files[0]?.name || "æœªé€‰æ‹©ä»»ä½•å›¾ç‰‡";
                imageInputName.textContent = name;
            };

            const previewName = document.getElementById("previewImageName");
            const previewInput = document.getElementById("previewImageInput");
            const clearBtn = document.getElementById("clearPreviewImageButton");

            // é€‰æ‹©åæ›´æ–°æ–‡ä»¶å
            previewInput.onchange = () => {
                const name = previewInput.files[0]?.name || "æœªé€‰æ‹©ä»»ä½•å›¾ç‰‡";
                previewName.textContent = name;
            };

            // æ¸…é™¤æŒ‰é’®ï¼šç›´æ¥æŠŠ value ç½®ç©º
            clearBtn.onclick = () => {
                const input = document.getElementById("previewImageInput"); // æ¯æ¬¡ç°å–ï¼Œé¿å…æ‹¿åˆ°æ—§å¼•ç”¨
                if (!input) return;

                input.value = ""; // æ¸…ç©ºé€‰æ‹©
                previewName.textContent = "æœªé€‰æ‹©ä»»ä½•å›¾ç‰‡";
            };
        };

        function setProgress(kind, pct, text) {
            const wrap = document.getElementById(kind + "ProgressWrap");
            const bar = document.getElementById(kind + "ProgressBar");
            const lbl = document.getElementById(kind + "ProgressText");
            if (!wrap || !bar || !lbl) return;
            wrap.style.display = "block";
            bar.style.width = Math.max(0, Math.min(100, pct)) + "%";
            if (text) lbl.textContent = text;
        }
        function hideProgress(kind, finalText) {
            const wrap = document.getElementById(kind + "ProgressWrap");
            const bar = document.getElementById(kind + "ProgressBar");
            const lbl = document.getElementById(kind + "ProgressText");
            if (!wrap) return;
            if (finalText && lbl) lbl.textContent = finalText;
            if (bar) bar.style.width = "100%";
            setTimeout(() => { wrap.style.display = "none"; }, 500);
        }
        function uiTick() { return new Promise(r => setTimeout(r)); }
        function formatBytes(n) {
            if (!Number.isFinite(n)) return n + " B";
            const units = ["B", "KB", "MB", "GB", "TB"];
            let i = 0, v = n;
            while (v >= 1024 && i < units.length - 1) { v /= 1024; i++; }
            return v.toFixed(v < 10 && i > 0 ? 1 : 0) + " " + units[i];
        }

    </script>
</body>

</html>
